


https://developer.android.com/develop/ui/compose/components?hl=zh-cn

components 组件

    Material components in Compose
    Jetpack Compose offers an implementation of Material Design, a comprehensive design system for creating digital interfaces. You can use composable functions to implement Material components.

    Compose 中的 Material 组件
    Jetpack Compose 提供了 Material Design 的实现，后者是一个用于创建数字界面的综合设计系统。您可以使用可组合函数来实现 Material 组件。


-------------
第一个概念：这些东西是加快开发的，基本的 row 和 Column 也可以使用，但是 我们无法做出复杂的交互，比如dialog
第二个概念：这些东西也是一个规范
           这个规范从教程(tutorial)的 第三条就可以看得出来 https://developer.android.com/develop/ui/compose/tutorial?hl=zh-cn



Material Design 是围绕 Color、Typography、Shape 这三大要素构建的。您将逐一添加这些要素。

Color（颜色）
Typography（排版）
Shape（形状）





-------------


在 Compose 中，以下 Composable 可以作为 容器 来包含其他 Composable：

Column（类似于 LinearLayout 纵向排列）
Row（类似于 LinearLayout 横向排列）
Box（类似于 FrameLayout）
ConstraintLayout（类似于 ConstraintLayout）
LazyColumn（类似于 RecyclerView）

-------------------

目前  Button 被设置成为容器了
@Composable
fun MyColumnLayout() {
    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Text("第一行")
        Text("第二行")
        Button(onClick = {}) {
            Text("按钮")
        }
    }
}

Button 作为一个容器，那就意味着他默认没有设置文本的属性了

@Composable
fun Button(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.shape,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    elevation: ButtonElevation? = ButtonDefaults.buttonElevation(),
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
)

----------


# 🚀 Jetpack Compose 常用组件介绍

| 组件 | 作用 |
| --- | --- |
| `Scaffold` | 页面基础框架，支持 `TopAppBar`、`BottomBar`、`Drawer` 等 |
| `TopAppBar` / `CenterAlignedTopAppBar` | 顶部栏（可添加导航按钮、菜单等） |
| `NavigationBar` | 底部导航栏（通常用于 `BottomNavigation`） |
| `DrawerSheet` | 侧边抽屉菜单 |
| `Button` / `OutlinedButton` / `TextButton` | 按钮（主要交互元素） |
| `TextField` / `OutlinedTextField` | 输入框 |
| `Card` | 卡片样式容器 |
| `Dialog` | 对话框 |
| `Snackbar` | 短暂消息提示 |
| `Checkbox` / `Switch` / `RadioButton` | 选择控件 |
| `LazyColumn` / `LazyRow` | 可滚动的列表 |



---------------------


# 🚀 Jetpack Compose 是否存在内存泄露？

在 **Jetpack Compose** 中，**理论上不会像传统 View 那样容易发生内存泄露**，但在某些情况下，**仍然可能导致内存泄露**，主要来源包括：

---

## **🚨 可能导致内存泄露的情况**

### **1. 记住了 `Activity` 或 `Fragment` 的引用**
在 `remember`、`rememberSaveable` 或 `LaunchedEffect` 里，如果你**错误地存储了 `Activity`/`Context` 的引用**，可能会导致内存泄露。

**❌ 错误示例（会导致 Activity 泄露）：**
```kotlin
val activity = LocalContext.current as Activity
val myObject = remember { SomeObject(activity) }  // ❌ 持有 Activity 引用
```

**✅ 解决方案：使用 `WeakReference` 或避免存储 Context**
```kotlin
val context = LocalContext.current.applicationContext // ✅ 只存 ApplicationContext
val myObject = remember { SomeObject(context) }
```

---

### **2. `LaunchedEffect`、`DisposableEffect` 没有正确释放资源**
`LaunchedEffect` 或 `DisposableEffect` 在 `Composition` 发生变化时可能会保留不必要的对象，导致资源无法释放。

**❌ 错误示例（监听 ViewModel，但没有正确取消）：**
```kotlin
LaunchedEffect(Unit) {
    viewModel.dataFlow.collect { data ->
        // 处理数据
    }
} // ❌ 如果 ViewModel 生命周期比 Composable 短，可能导致泄露
```

**✅ 解决方案：使用 `collectAsState`**
```kotlin
val data by viewModel.dataFlow.collectAsState()
```

---

### **3. `rememberCoroutineScope()` 在 `Composition` 外部使用**
**❌ 错误示例（使用 `rememberCoroutineScope()` 但没有手动取消）：**
```kotlin
val coroutineScope = rememberCoroutineScope()
coroutineScope.launch {
    // 执行长时间任务
}
```

**✅ 解决方案：使用 `LaunchedEffect` 或 `rememberUpdatedState`**
```kotlin
LaunchedEffect(Unit) {
    // 在 Composable 生命周期内管理协程
}
```

---

### **4. `CompositionLocal` 不当使用**
如果 `CompositionLocal` 存储了一个生命周期较长的对象（比如 `Context`），并且该对象被 `Composable` 长时间持有，可能会导致内存泄露。

**✅ 避免直接存 `Activity`，用 `ApplicationContext`**
```kotlin
val context = LocalContext.current.applicationContext
```

---

## **📌 结论**
**Jetpack Compose 相比传统 View，更不容易发生内存泄露**，但仍需要注意以下几点：
- **不要在 `remember` 里存 `Activity`，改用 `ApplicationContext`**
- **正确使用 `LaunchedEffect`，避免长时间持有 `ViewModel`**
- **合理管理协程，确保 `CoroutineScope` 在 `Composition` 结束时被释放**
- **`DisposableEffect` 用于释放资源**

**如果正确使用 `remember`、`LaunchedEffect`、`ViewModel`，基本不会发生泄露！🚀**


















































































































































































































































































































































































































































































































